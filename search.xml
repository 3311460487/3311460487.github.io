<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件测试学习（三）]]></title>
    <url>%2F2019%2F12%2F11%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89-BUG%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;BUG的管理包括：BUG的管理平台、BUG的六要素、BUG的生命周期、BUG的状态、BUG的等级。 整体导图 正文一、BUG的管理平台&emsp;&emsp;在测试过程中，发现BUG之后肯定是要记录BUG的，这些BUG的记录是有一些平台的。常见的BUG管理软件/工具：&emsp;&emsp;1. 禅道；&emsp;&emsp;2. BUGFree&emsp;&emsp;3. ALM/QC&emsp;&emsp;4. Testlink&emsp;&emsp;5. Bugzilla&emsp;&emsp;6. JIRA&emsp;&emsp;老师的评价为，以上的BUG管理工具，核心内涵都是一样的，都是差不多的，区别在于页面不一样，长得不一样等，其他基本的逻辑都是差不多的。 二、BUG的六要素&emsp;&emsp;一般在提BUG的时候，是需要对其详细信息进行记录的，这就涉及到的BUG的六要素，包括：BUG的编号、BUG的名称、BUG的优先级、BUG的严重级别、BUG的复现步骤、附件。&emsp;1. BUG的编号&emsp;&emsp;编号是绝对唯一的。如果用禅道，那么会自动生成编号。如果是Excel文档，则需要自己进行编号。&emsp;2. BUG名称&emsp;&emsp;言简意赅，看到题目就知道是什么问题。&emsp;3. 优先级&emsp;&emsp;根据实际情况，该BUG是否需要优先解决。优先级分为高、中、低三级&emsp;4. BUG的等级&emsp;&emsp;BUG的等级又分为四级：&emsp;&emsp;a. 致命的/一级/A：&emsp;&emsp;&emsp;影响产品的核心流程的正常使用；&emsp;&emsp;&emsp;导致软件挂了、闪退、崩溃；&emsp;&emsp;&emsp;和钱有关；&emsp;&emsp;b. 严重的/二级/B：&emsp;&emsp;&emsp;导致了功能无法正常使用。&emsp;&emsp;c. 一般的/三级/C：&emsp;&emsp;&emsp;功能的某些异常场景问题（例如在注册界面，用户注册了已经存在的账号但是也成功了）&emsp;&emsp;&emsp;“严重的”和“一般的”划分的时候比较主观，二者有时候会比较模糊。&emsp;&emsp;d. 轻微的/四级/D：&emsp;&emsp;&emsp;建议性的东西，用户体验的、UI上的问题等等。&emsp;5. BUG的复现步骤：&emsp;&emsp;a. 操作步骤（可以把用例的步骤复制过来）&emsp;&emsp;b. 预期结果&emsp;&emsp;c. 实际结果&emsp;6. 附件&emsp;&emsp;附件是用于佐证该BUG确实存在。找BUG是找开发的问题，如果没有证据的话有可能会不被认可。附件可能是：&emsp;&emsp;a. 截图&emsp;&emsp;b. 日志&emsp;&emsp;c. 操作小视频 三、BUG的生命周期当测试人员提交了BUG起，一个BUG就诞生了，并开始了自己的声明周期。 四、BUG的状态 新建/new 打开/激活/open 已确认 已解决 拒绝 重新打开/reopen 关闭/closed 延期处理 重复BUG]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（三）]]></title>
    <url>%2F2019%2F12%2F11%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89-%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[（接上文） 测试执行阶段&emsp;&emsp;本阶段即为，照着写好的测试用例一条一条执行，然后把实际结果记录在里面。如果预期结果和实际结果一样，则没有问题；如果预期结果和实际结果不一样，则有问题，需要提BUG。 一、执行测试用例&emsp;&emsp;对照测试用例一条一条进行执行，然后和实际结果作对比，如果一样则通过，如果不一样则有问题。 二、提交BUG&emsp;&emsp;提交BUG涉及到相关的BUG管理平台、BUG六要素等等。 三、回归测试&emsp;&emsp;就是在版本2上去检查在版本1上发现的问题有没有被解决。 四、什么是版本迭代&emsp;&emsp;随着时间/测试次数的推进，会发布很多版本，其中版本号是不断叠加的。在面对版本迭代的情况下，则会出现以下两个情况：1.增量测试：&emsp;&emsp;只测试已知的有变化的部分，这个时候为了应对开发改一行，测试测一天的情况，公司会退出自动化测试，只对增量的部分进行人工测试，之前的部分由电脑自动完完成。2.全量测试：&emsp;&emsp;每发布一个新版本，都要去测试软件中的所有功能。这种情况在软件越来越大之后是不现实的。（正所谓开发改一行，测试测一天）]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（三）]]></title>
    <url>%2F2019%2F12%2F11%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89-%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;测试需要注意的是：怎么测，从哪里去测，测试的过程，而不是随便在软件上乱点，所以一般是需要“地毯式”的测试。&emsp;&emsp;测试用例可以给测试人员提供工作的依据，且一般是交叉进行的：即为甲负责ABC模块测试用例，乙负责DEF模块测试用例，在双方写完对应模块之后，交换进行交叉测试，以防止测试人员陷入思维僵局。&emsp;&emsp;如果测试用例是由之前的需求分析书转换而来的，则测试用例可以利用整个软件的需求来计算覆盖率。常识补充：&emsp;&emsp;测试是无穷无尽的。&emsp;&emsp;以QQ注册为例，其昵称填写和密码填写的内容会有非常多种组合。这里的测试无穷无尽，是因为测试的数据是无穷无尽的。&emsp;&emsp;有比如在微信中发单个红包，其最额度为0.01——200，递增量为0.01，则测试值就有两万个之多，如果又是上限为100人的群发红包，则测试值就变得更多。 本节思维导图总览 正文&lt;一&gt;、测试方法&emsp;&emsp;这里的测试方法是讲如何设计测试用例的。&emsp;&emsp;黑盒白盒测试教你加减乘除，这里的测试方法测试详细的一加一等于二，这些测试方法在任意的测试思路里都可以使用。测试方法包括：等价类、边界值、场景法、因果图、判定表、路径覆盖法，这里仅进行前三种的测试，且这些方法多用于黑盒测试，相对于其他类的方法效率更高一些，当然也有缺点。（一）等价类： &emsp;&emsp;指的是，通过少量数据来代表大量数据——找出最具有代表性的值。测试人员需要知道一个重要的常识：测试是无穷无尽的。为了应对这样的情况，就需要在数值中找出一个等价类，以代表大多数的数据。等价类又分为有效等价类和无效等价类，这里以微信发红包为例：1.有效等价类：&emsp;&emsp;有效值中的代表，例如0.01、50、200。2.无效等价类：&emsp;&emsp;无效值中的代表。例如0、201。3.边界值：&emsp;&emsp;一般在需求文档里面，会具体描述每个功能的逻辑和限制，例如微信发红包里面，会写明限额在0.01——200之间，那个0.01和200就是发红包的边界值。另外，在开发人员编写的代码里面，也会体现出一个输入的边界值，以下面的伪代码为例：（注：上课的时候老师写的伪代码有一点错误，应该使用且而不是或运算）&emsp;&emsp;边界值一般用于找出测试数据中的等价类，在选择数值时候，需要选择典型的值：0.01、0.02；200、199.99。&emsp;&emsp;上面四个值都非常接近边界值，属于较为极限的情况，为了保险起见，还需要一个中间值，例如50。&emsp;&emsp;除此之外，为了找到无效等价类，需要找出在范围以外的数值，如200.1和0 。&emsp;&emsp;等价类和边界值，主要是用于找出测试数据时使用的。 （二）场景法：&emsp;&emsp;指用户在使用一个功能时，他会遇到那些场景，会怎么操作，以微信发红包为例。（注意，密码错误、没钱、没网是比较复杂的情况，会在其他情况下进行测试，这里不进行讨论。）&emsp;&emsp;仅以发送红包为例，可以从发送成功和发送失败来考虑：1.发送成功：&emsp;&emsp;用户输入符合要求的金额，发送红包成功。&emsp;&emsp;这里在测试时，就需要利用等价类的方法来进行述职输入，例如0.01,20,200 。2.发送失败：&emsp;&emsp;a. 用户什么都不输入，点击发送；&emsp;&emsp;&emsp;0.01,200 。&emsp;&emsp;b. 用户输入超出范围的值，不能发送成功；&emsp;&emsp;&emsp;201,0 。&emsp;&emsp;c. 用户输入非数字的值，不能发送；&emsp;&emsp;&emsp;字母、汉字、符号等输入。这测试非法字符的情况，就是变相的在测试输入键盘是否被规定。&emsp;&emsp;一般来讲，限制的条件和规则越多，测试的场景就越复杂。 &lt;二&gt;、测试用例&emsp;&emsp;目前大部分公司在写测试用例时，采用Excel表格进行编写。测试用例包括：用例编号、用例名称、前置条件、优先级、重要级、测试数据、测试步骤、预期结果、实际结果等。这几种内容都是必须要有的，其他的内容，例如附件等等，是可有可无的。1.用例编号：&emsp;&emsp;是绝对唯一的。2.用例名称：&emsp;&emsp;要求言简意赅，用最少的字描述清楚这个用例是做什么的。3.前置条件：&emsp;&emsp;在执行这个用例之前，软件必须要满足的条件。4.优先级：&emsp;&emsp;执行该用例的时间要求紧急的等级。因为一个软件不是一次性做完的，而是会分为一期、二期、三期等来慢慢完成，一般来讲一期的任务的优先级要更高一些。5.重要级：&emsp;&emsp;被测功能在系统里面的重要级别。重要级指的是测试的功能点在整个系统里面是否重要，例如微信的发送语音功能和朋友圈点赞功能，很显然发语音的重要级比点赞的重要级高。重要级的判断是依据软件的业务，如果涉及到核心的业务，则重要级高，反之则较低。&emsp;&emsp;这里给出注册QQ号的实际例子： &emsp;&emsp;优先级是根据时间来划分的，重要级是根据功能来划分的。在有限的时间里会对相同的优先级的测试用例里挑出重要级高的来进行测试。（网友说先上凉菜是优先级，主食是重要级，我觉得比较生动贴切。） &lt;三&gt;、练习&emsp;&emsp;以下图中的账号注册为例，进行测试用例的编写： &emsp;&emsp;很多测试人员在一开始会发现测试用例越写越多，无穷无尽，这个问题需要长时间的积累和经验判断来进行解决。一些典型的小网站，其测试用例有七八百条，而淘宝网有上万条则都不算多。写测试用例有可能都会花费几个月的时间来进行，在写得多有经验之后，就会明白那些情况是重复的，这个时候就要斟酌如何用典型的测试用例来代表其他的用例。（这里老师展示了一个实际工作中的测试用例，其数量达到三百多条）： 补充&emsp;&emsp;在测试设计阶段，会对测试用例进行评审，这个时候会把大家都叫过来进行开会，然后每个人一条一条解释自己的用例是什么意思，如何操作等等。如果发现有问题，则需要拿回去修改，然后进行二审。评审分为以下几种：1.同行评审&emsp;&emsp;同部门的另外一个测试人员进行评审。2.小组评审&emsp;&emsp;整个测试部门来进行评审。3.部门评审&emsp;&emsp;整个部门进行评审。4.项目评审&emsp;&emsp;整个项目的人都前来进行评审，包括项目经理，开发人员，产品经理等等。5.第三方评审&emsp;&emsp;会包含项目以外的人，例如客户、其他部门打酱油的等等。6.邮件评审&emsp;&emsp;就是通过发邮件进行评审，不进行面对面开会。]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（二）]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%A0%94%E5%8F%91-%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;本节是视频课程中的最后一部分，接着上一部分进行记录，这一节主要讲述了软件测试的流程。 参考资料&emsp;&emsp;本节内容对应的是下面第二条网课中的第二节。 所有资料来源： 如何从零开始学习软件测试 本节课程资源来源：02软件研发模型和测试流程 博客所使用的思维导图为：凹脑图 正文本节思维导图 &emsp;&emsp;下面的流程是目前绝大多数公司所采用的流程 一、需求分析阶段需求分析主要做以下事情：1.需求分析&emsp;&emsp;想要写好需求分析，首先要明白什么是需求。（另，需求分析其实就是在做第2——4点的事情。）&emsp;&emsp;一般来讲，需求有三种表现形式：&emsp;&emsp;a. 需求文档&emsp;&emsp;&emsp;产品经理在拿到需求过后，会将需求整理成文档，对软件的功能进行描述，包括表现形式和要求等等。&emsp;&emsp;b. 产品原型&emsp;&emsp;&emsp;以墨刀为例，它会画出产品具体的样子，让开发人员能够有一个直观的感受，并且其中的页面是可以进行点击的。一般产品原型由产品经理来画,如下图：&emsp;&emsp;c. 口述&emsp;&emsp;&emsp;常见但是最低效的方式。2.学习业务流程&emsp;&emsp;对于测试人员来说，首先要知道软件的功能和流程，明白它是要做什么。上面图画中的软件相对于来说要简单一些，不过如果涉及到比较专业的领域，如银行金融业、会计专业测试等等，不过一般有的公司会对开发人员进行相关领域的知识进行培训，以让开发人员明白应该怎么测试，如果去面试的话了解这些，那么都一般是加分项。3.提取功能点&emsp;&emsp;就是从打到小把一个软件的功能提取出来，然后写清楚。以慕课APP为例，见下图：&emsp;&emsp;根据图中的展示，首先可以分为“首页”、“发现”、“下载”、“我的”。其次，再将每个页面进行细化，例如不同的区域、模块等等，在完成这一步之后，继续进行划分，最终找到最小的功能点——就是无法再继续划分的功能。&emsp;&emsp;将上述步骤完成之后，能够画出一个树状图来，就称之为“提取功能点”，见下图：&emsp;&emsp;在功能点提取出来之后需要备注描述，以说明该功能点具体要实现的效果和具体要求。例如，在注册时，要求昵称里面只能包含数字、字母等等；哔哩哔哩网站在输入密码的时候旁边的漫画形象会有所变化等等。4.编写需求分析说明书&emsp;&emsp;该阶段就是把第3点中的树形图转化为文档，Excel和Word不限。 注意：需求文档是产品经理写的，需求分析说明书是测试工程师写的。没有需求怎么办？&emsp;&emsp;参考市面上已经成熟的同类型的产品的实现。例如，你要做一个购物商城，可以去参考侧面上已经成熟的购物APP的实现。这里的参考不是去参考他们的页面布局，而是里面的流程和逻辑，例如昵称注册要求等等。 二、测试设计阶段&emsp;&emsp;在需求阶段完成之后就进入了测试设计阶段，本阶段又称为文档阶段，其内容包括：1.测试计划&emsp;&emsp;重点内容是时间和人员、以及资源的安排分配。2.测试方案&emsp;&emsp;其内容重点在于：&emsp;&emsp;a. 针对每个测试内容如何开展测试；&emsp;&emsp;b. 采用什么测试计划；&emsp;&emsp;c. 什么测试工具；3.测试策略：&emsp;&emsp;a. 那些测试先测试；&emsp;&emsp;b. 那些测试后测试；&emsp;&emsp;c. 开始测试和结束测试的标注是什么；注意：以上三点都可以采用5W1H方法进行编写，且在更多情况下，这三点会被合并成一个文档，合并之后的文档就称为测试计划说明书。实际工作中，一般这些文档的编写套模板即可。4.测试用例&emsp;&emsp;要求每一个测试人员必须会写。其他三项一般由测试组长或测试经理来进行编写。优秀的测试养成攻略 测试能力 文档能力 编程能力以上三种能力缺一不可，其中文档能力是测试人员非常重要的能力。 补充内容：优秀的测试养成攻略： 测试能力 文档能力 编程能力 以上三种能力缺一不可，其中文档能力是测试人员非常重要的一项技能。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（二）]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;本节接着上一篇文档继续，原视频中的第二节课一共133分钟，所以我这里将其相关笔记也拆分成了多份。 参考资料本节内容对应的是下面第二条网课中的第二节。 所有资料来源： 如何从零开始学习软件测试 本节课程资源来源：02软件研发模型和测试流程 博客所使用的思维导图为：凹脑图 补充知识&emsp;&emsp;视频中老师在将测试流程的时候，中间穿插了一些补充内容，由于和本节内容并不在一个体系内，所以这里拿出来单独说明。 互联网公司的内部结构 正文思维导图 一、瀑布流&emsp;&emsp;我们知道，瀑布是从上往下的，是不可逆转的，顾名思义，瀑布流就是指在开发过程中有一个从上往下的过程，只有完成前一步之后才能进行后一步，而且是不可逆转的，如果想要重返第一步，那也之后完成最后一步之后才能重头开始，其流程图如下：&emsp;&emsp;可以看到，各个步骤之间是独立的。优点：&emsp;&emsp;• 上下级之间是独立、分离的。缺点：&emsp;&emsp;• 无参考&emsp;&emsp;• 不变通，如果在后期发现有问题，那么这个时候是无法进行修改的，只有硬头皮继续做下去，否则就推到重来。补充说明：&emsp;&emsp;1.需求分析：产品经理收集需求，将这些需求进行整理并设计出来，之后邀请开发一起对需求进行分析，了解该产品想要被做成什么样。&emsp;&emsp;2.制定计划：项目经理制定软件开发计划。&emsp;&emsp;3.系统设计：开发进行系统设计，例如采用什么样的技术、什么样的框架等等。&emsp;&emsp;4.编码：程序员开始写代码。&emsp;&emsp;5.测试：测试人员进行测试。&emsp;&emsp;6.交付：即最后的验收，在委托方确认之后整个流程即结束。瀑布流因为其不可逆转性而表现的效率比较低，目前已经被淘汰。 二、V字型&emsp;&emsp;V字型也是一个从上往下的过程，但是相对于前面的瀑布流，它多了一个一一对照的关系：&emsp;&emsp;左边的那一部分是开发的工作，右边的工作是测试的工作，V字型模型就是把测试的工作和开发的工作有了一一对照的关系：单元测试的依据是开发写的代码、集成测试的依据是开发写的详细设计。。。&emsp;&emsp;相对于之前的瀑布流，有了一个进步，但是依然不明显。不过因为有个对照，测试人员就可以很快上手工作，可以节约很多时间。&emsp;&emsp;这里需要说一点的是，前面提到了，软件由程序、文档、数据构成，测试人员测试的不仅仅是程序代码，还有开发其他两个部分，例如测试人员在写测试设计的时候，会参考开发人员写的概要设计，这个时候就会对概要设计进行简单的测试。 三、W模型（双V模型）&emsp;&emsp;如上图所表现出来的，W由两个V构成，左边的那个V是开发人员所做的事情，右边是测试人员所做的事情，他们的对照也变成了V字和V字之间的对照，开发和测试工作也变成可以同步进行了：开发在做用户的需求分析时，测试也在写用户需求、开发在概要设计时，测试在编写测试设计。这样，测试人员不需要等开发结束之后再进行测试，这样大大节省了时间，同时也可以随时进行沟通。&emsp;&emsp;核心特点：&emsp;&emsp;&emsp;&emsp;开发和测试同步。&emsp;&emsp;W模型也是目前绝大多数公司正再用的模型。 四、敏捷模型&emsp;&emsp;敏捷模型区别与前面的三个模型，它是目前比较流行的趋势，不过由于敏捷模型是前几年才提出的概念，因此大多数公司目还正处于摸索的阶段。&emsp;&emsp;其特点为：&emsp;&emsp;&emsp;1.高效的工作；&emsp;&emsp;&emsp;2.及时的沟通；&emsp;&emsp;还有一些工作形式：&emsp;&emsp;&emsp;1.工作日版；&emsp;&emsp;&emsp;2.白板；&emsp;&emsp;&emsp;&emsp;将目前的项目进度和情况写在白板上，这样每个人都清楚彼此的进度和进展。&emsp;&emsp;3.站立会；&emsp;&emsp;4.集中/联合办公；&emsp;&emsp;&emsp;&emsp;就是把项目组开发和测试等人员安排到一个办公室里，这样出现问题之后就可以直接进行交流，大大提高了工作效率。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（二）]]></title>
    <url>%2F2019%2F11%2F19%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言本节内容接着上部分进行记录，由于上一节中，老师讲了一部分的测试分类，本节又讲了很多，因此在画思维导图的时候，我将软件测试的分类单独画出了一张图。 参考资料本节内容对应的是下面第二条网课中的第二节。 所有资料来源： 如何从零开始学习软件测试 本节课程资源来源：02软件研发模型和测试流程 博客所使用的思维导图为：凹脑图 正文整体思维导图 软件测试的分类（接上文） 根据阶段来分类：&emsp;a. 单元测试：&emsp;&emsp;所谓单元，即为软件在开发过程中不同的代码模块，开发人员会根据不同的功能把他们写成不同的单元，如下图中不同类型的图案：&emsp;&emsp;代码块可以集合成不同的小模块，相当于完成了不同的功能模块，例如“用户管理模块”，“订单管理模块”等等，完成这一步相当于完成了单元开发的过程。&emsp;&emsp;单元测试就是对这些小的单元代码块进行测试，其重点也就是这些代码模块（中的方法、函数、类），如下图：&emsp;&emsp;你可以把它理解为一个函数，虽然这样有失准确。&emsp;注意，单元测试就是具体到每个单元里面的方法、函数、类；&emsp;另外，需要记住的就是，单元测试测试的是代码。&emsp;b. 集成测试：&emsp;&emsp;一个软件在开发时候会有分工合作，如开发A开发A模块，B团队开发B模块，当各个模块开发结束之后，这些模块会被集成起来。所谓“集成”就是把这些不同的模块按照设计通过接口连接起来。&emsp;&emsp;集成测试这个时候需要检测的就是开发在不同的模块之间连接的对不对，如下图，模块之间的通道即为接口，本阶段的测试重点就在于这些“通道”。&emsp;&emsp;接口：模块与模块之间数据互相发送、传送的一个通道，以下图为形象例子：&emsp;&emsp;通过这样的一个“接口”，实现不同模块之间的数据流入或者流出。&emsp;c. 系统测试：&emsp;&emsp;完成集成之后，这些代码就形成了一个整体或者系统（该阶段已经形成了完成的软件），如下图：&emsp;这个时候主要测试软件的功能、性能、安全、兼容性、易用性、UI等等。&emsp;&emsp;&emsp;i. 兼容性：&emsp;&emsp;&emsp;&emsp;兼容性又分为WEB的兼容性和APP的兼容性。&emsp;&emsp;&emsp;&emsp;所谓WEB兼容性就是指同一内容在不同浏览器上的表现是怎么样的。例如我有时候在浏览一些网站时，它在IE上和360极速浏览器上就会显示不一样，这可能是因为不同网站的实现方式、不同浏览器对数据的解析不一样。&emsp;&emsp;&emsp;&emsp;首先APP分为安卓和IOS两个系统。安卓系统其使用量非常广泛，且不同手机生存厂家为了增加自己品牌的功能，并不会支架使用安卓系统，而是会在里面进行改装，这个时候就需要检测同一款APP在不同机型上的表现如何。而IOS的兼容性则是为了检测在不同的苹果手机型上的表现。&emsp;&emsp;&emsp;ii. 易用性：&emsp;&emsp;&emsp;&emsp;易用性主要检测的是软件的用户体验，无论网站还是APP，在用户使用的时候都要感受一下其设计是否适合使用习惯，是不是好用的，这一测试一般会比较主观，如果用户觉得有问题的话，一般就会向产品经理进行反馈。&emsp;&emsp;&emsp;iii. 稳定性测试：&emsp;&emsp;&emsp;&emsp;该测试是为了检测一个软件在已知使用的情况下是否会出现问题、崩坏等等。例如，你在已知使用一个APP，从来不关了它，并且达到的一般默认的7×24小时，如果在这种情况下软件没有问题出现，那么就说明这个软禁的稳定性是合格了的。&emsp;&emsp;&emsp;iv. UI测试：&emsp;&emsp;&emsp;&emsp;UI就是软件的界面，该测试就是为了检验软件的界面是否好看，例如其排版、颜色布局、按钮的设计、风格是否同意等等，该测试也较为主观。&emsp;&emsp;&emsp;&emsp;另外一种情况就是，该软件在最开始是有美工设计图的，呢么这个时候就可以检查成品和设计图是否一致，如果不一致就让开发去改即可。&emsp;&emsp;d.验收测试：&emsp;&emsp;&emsp;在完成系统测试之后，我们需要把软件交付给用户或者甲方去使用，这个时候用户就会看和她们的要求是否一样，例如是否实现了登录功能，能够发送文件等等。当然现在很多公司都会有自己的IT部门，这个时候公司的产品经理、老板过来查看整个软件的情况，这也叫验收测试，这个时候对于测试工程师来说，只需要陪着他们就好了。（这可是老师说的哦）&emsp;2. 按照对象来进行分类：&emsp;&emsp;该分类下包括APP测试、WEB测试、物联网测试、车联网测试、小程序测试等等。&emsp;3. 按照软件状态来进行分类：&emsp;&emsp;a. 静态测试：&emsp;&emsp;&emsp;就是软件没有运行起来时候进行的测试，如白盒测试。&emsp;&emsp;b. 动态测试：&emsp;&emsp;&emsp;就是软件运行起来的时候进行的测试，如黑盒测试。&emsp;4. 其他分类：&emsp;&emsp;a. 冒烟测试：&emsp;&emsp;&emsp;又称为“测试前的测试”。例如，测试人员在刚拿到一个软件之后，测试人员会首先大概检查一下这个软件是否具有“可测试性”，假如这个软件发现了开发那边一眼就能发现的问题却没有修改好直接就发给测试部门，这种情况就称之为“冒烟测试”未通过，这个时候软件要被送回开发部门进行修改。&emsp;&emsp;b. 回归测试：&emsp;&emsp;&emsp;属于测试流程里面的一种测试。例如一个已经发现的bug，在开发部修改好之后，改完进行二审的过程，就称之为回归测试。&emsp;&emsp;c. α测试：&emsp;&emsp;&emsp;即内测，一般在软件开发出来之后，会找一些公司内部的一小部分人来先试用一下，这样称之为内测。&emsp;&emsp;d. β测试：&emsp;&emsp;&emsp;又称之为公测。以游戏王者荣耀为例，游戏一般在发布新的版本、新的英雄之后，都会先上线体验服让一部分玩家进行试玩，同时收集体验服玩家的建议，如果出现了大问题，则会将更新的部分回炉重造。]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试学习（一）]]></title>
    <url>%2F2019%2F11%2F18%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言博主最近因为一些原因，需要快速学习完关于软件测试的理论知识和相关的应用技术，为此，博主也是在各大网站中看相关问题，搜集了一些学习资料。本博客的目的在于记录博主在软件测试学习中的情况，也许未来博主不从事软件测试职业，但是这个时候，多学一些相关的知识总是没错的。 参考资料我把参考资料放在前面是因为，这些博文里面的内容几乎都是按照他们来的，而博文是我对这些学习资料的转述，因此如果想学更直接的知识，可以在下方的连接中直接跳转。以下资源查找来自知乎问答和哔哩哔哩： 所有资料来源： 如何从零开始学习软件测试 本节课程资源来源：01软件测试的介绍和分类 博客所使用的思维导图为：凹脑图 概述本节内容包括：软件测试的行情（本博文里面没有记录）、软件测试的发展历程、软件测试的职业发展和软件测试的分类。学习资料是视频，老师在视频中画出了思维导图，我这里将它重现了出来。里面概念的介绍和解释由于是口头讲述的，因此在视频中并没有以文字的形式展示出来，我在这里都进行了记录。首先看一下本章的思维导图： 正文一、什么是软件测试？&emsp;以修房子比作软件，开发是修房子，测试就是按照开始的设计图对整个房子进行检查： 房子结构是否和设计图一样； 建造材料是否和设计的一样； 建造方式是否和设计的一样； &emsp;所以，软件测试就是检查开发出来的软件是否符合最开始的需求，其功能是否符合预期结果。 二、软件测试的三个阶段1.0 软件测试就是去证明软件是正确的&emsp;&emsp;最早的时候因为开发出来的软件有时候总是出现各种各样的问题，因此人们提出了软件测试的概念。这个时候的软件测试，主要是为了检验开发出来的软件是否能够完成设计的功能，这其实要求用户在使用软件时只能进行“正确的”操作。 2.0 软件测试是去证明软件是错误的&emsp;&emsp;该阶段开始找出软件的各种各样的错误，即考虑到了用户非法输入的各种各样情况，增加了软件的健壮性。 3.0 软件测试是保证软件的质量是符合用户需求的一系列手段&emsp;&emsp;该阶段，软件开发由于其体积日益增大，已经上升为了“软件工程”，有工程就有了组织，有组织就有了流程。软件开发的方方面面也都成为了软件测试的关注内容，从单纯的软件功能，扩大到了软件的质量。&emsp;&emsp;做软件测试的目的不是为了发现bug，而是预防bug，这样的境界当然比发现bug高，其考验的也更偏向流程方面啦。&emsp;&emsp;在国外，软件测试更偏向质量控制，主要依靠流程管理来控制软件质量；在国内，软件测试主键发展为了以技术发展为主来控制软件质量。两者对比，可以发现软件测试在国内对技术的要求会更高一些，因此也出现了“测试开发”岗位等等。 三、软件测试的职业发展&emsp;&emsp;一般来讲，刚进入软件测试的岗位，基本上都是功能测试。在经过一段时间的沉淀之后，就会有以下三条路可以走： 自动化测试工程师 性能测试工程师 转行 &emsp;&emsp;通常情况下，第1条和第2条并不是互斥的，而是两个都会但是更偏向的。性能测试工程师入门较容易，但是想要有所成长，变为高价性能测试工程师的话，有很长的路要走，而且对应的岗位“架构师”，也是一个非常耀眼的职位哦。 四、软件测试的分类1. 根据测试的方法进行分类&emsp;&emsp;以下三个测试方法是测试人员都需要掌握的，其区别在于测试思维的不同；&emsp;&emsp;a. 黑盒测试：&emsp;&emsp;&emsp;把软件当成一个不透明的盒子，其内部结构和流程未知，测试人员只对外部暴露出来的交互接口、输入与输出、提供的功能进行检查，查看其是否和设计中的功能要求符合。该测试不关心软件在实现某功能，完成某要求时内部具体采用了什么方法。&emsp;&emsp;b. 白盒测试：&emsp;&emsp;&emsp;软件内部的流程、数据的传输与设计都能够看得到。该思路的测试就是通过去检查软件的内部结构和内部关系，来判断其功能是否实现，一般在软件测试中最直观的表现就是看代码，检查软件的代码是否正确。&emsp;&emsp;c. 灰盒测试：&emsp;&emsp;&emsp;&emsp;介于上面两者之间，同时使用黑盒测试和白盒测试。 2. 按照测试方向来分类&emsp;&emsp;该分类方法把软件测试分为了三部分：功能测试、性能测试、安全测试，这三种测试其含义倒过来念即可：测试功能、测试性能、测试安全。&emsp;&emsp;举例来说，所谓“功能”即软件提供的具体服务，如微信可以聊天，凹脑图可以画思维导图，QQ还可以修改密码等等。&emsp;&emsp;a. 功能测试&emsp;&emsp;&emsp;有些地方把黑盒测试和功能测试进行等同，该说法是错误的。因为两个名词是根据不同的分类方法得出来的，功能测试是针对软件的一个功能进行的测试，而黑盒测试是对软件测试的一个方法，对一个功能进行测试的时候，可以用黑盒、白盒、灰盒测试，只不过是因为在进行功能测试的时候，一般多用黑盒测试。&emsp;&emsp;&emsp;举例子说明，把功能测试比作“吃饭”，黑盒测试是用筷子吃饭、白盒测试是用勺子吃饭、灰盒测试是用叉子吃饭，这个时候很明显“用筷子吃饭”和“吃饭”不是等同的，只不过在大家日常生活中，用筷子吃饭多一些，这一点需要特别注意。&emsp;&emsp;b. 性能测试&emsp;&emsp;&emsp;“双十一”淘宝，春运时12306的抢票，都会出现拥挤无法正常使用服务的情况——而平时的时候就是好的，这就是因为性能不足。&emsp;&emsp;&emsp;所谓性能测试，就是去检测服务器/程序是否能够达到这么高。如果功能测试是检验软件能不能达到，那么性能测试就是检验其能够做得有多好。&emsp;&emsp;&emsp;性能测试中，又分为一下三点：&emsp;&emsp;&emsp;i. 负载测试：&emsp;&emsp;&emsp;&emsp;比喻说明，假设你家开了一个食堂，你想知道你家食堂能同时支持多少人来吃饭，于是你找了800人来模拟一下，发现有空余，于是就又找了1000人来测试，发现超过了，于是你减少来模拟的人数，发现900人刚刚好。这种找到你家食堂瓶颈的过程就成为负载测试——模拟主键增加的用户，去发现软件的用户人数在哪里。&emsp;&emsp;&emsp;&emsp;总结一句，即为：发现软件的性能瓶颈（注意这里不仅仅是指用户人数）。&emsp;&emsp;&emsp;ii. 压力测试：&emsp;&emsp;&emsp;&emsp;同样以食堂为例子，食堂有打菜的阿姨和师傅，而他们工作是有效率这一说的。当你家食堂搞了一个“一人付费，全家吃饭”的活动时，你家食堂突然就变成了即使不在饭点人也爆满的情况，这个时候你不知道这些师傅和阿姨能持续工作多久，能否承受这样的工作压力，所以说就需要压力测试了——对于持续的要强度工作，软件能够保持多长时间。和负载测试不一样，压力测试需要一个持续的时间，在做压力测试的时候，不会以峰值来要求软件持续工作，而是会留有一定的空间。一般在测试时，会采用峰值的80%-90%来进行模拟。&emsp;&emsp;&emsp;iii.并发测试&emsp;&emsp;&emsp;&emsp;并发是指同一瞬间，当有多个人操作同一件事情时软件的出错情况，如：整点秒杀时有多个人在同一时间抢到了该怎么办、两个人在同一时间下单之后会不会出现发错单的情况等等。&emsp;&emsp;c. 安全测试&emsp;&emsp;&emsp;对系统的抗攻击，盗取身份信息等等。该分支所需要学习的技能与软件测试主要的知识相差较远。一般在测试过程中会模拟黑客对系统进行攻击。&emsp;&emsp;将测试比作吃饭，功能测试是检测一个人能吃什么、性能测试是检测一个人吃的有多快、能吃几碗。（有网友弹幕说安全测试就是看吃了饭之后是否会中毒，我个人觉得这个比喻还是可以哒）]]></content>
      <categories>
        <category>学习笔记</category>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java爬虫新闻爬取jsoup解析（一）]]></title>
    <url>%2F2019%2F10%2F28%2Fjava%E7%88%AC%E8%99%AB%E6%96%B0%E9%97%BB%E7%88%AC%E5%8F%96jsoup%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java爬虫+jsoup解析（一）前言博主最近有一个APP开发的项目（其实就是期末作业），作为一个有梦想的学生，本人雄赳赳气昂昂的选择了做一个新闻浏览的APP。既然涉及到新闻浏览，肯定要爬取那些大型新闻网站的新闻撒，而且是先爬取所有信息列表，再爬取详细内容，这样功能才比较全面。但是博主在利用爬虫进行爬取的时候也是费劲巴拉的，本人爬虫小白，只能从网上找代码直接copy，于是问题就出现了。本篇博客主要意义不在于记录爬虫代码和解析技术，而在于记录一个爬虫的坑。 确定网站首先肯定要想好爬取什么网站的新闻，博主一开始选择了腾讯新闻科技板块的区块链部分按照爬虫流程，先利用代码得到HTML文档： 短短几行就得到了目标网站的HTML文档了，是不是很简单呢？接下来按照博主上次的博客指导，通过抽取元素，获取每一条新闻的标题和图片，于是就完成了APP中的一小步！ 分析目标网站在目标网站处按下F12查看元素进行网页分析，找到想要得到的标题列表部分，博主在这愉快的发现它们是table格式，也就是说在后面解析的时候会比较方便（毕竟之前有过代码）： 发现问题及记录问题就是在解析HTML的时候出现的，每次博主通过代码在HTML里面想要获取到那个关键的list时，总会出现各种各样的问题，要么输出null，要么干脆有什么都没有，于是博主本人开始了漫长的网上冲浪过程，具体过程包括：到处找其他的办法解析HTML；找其他的方法获取元素；自习阅读jsoup中文文档，找到第那里出了问题；换其他的大型网站，比如网易、新浪等等。于是就这样过去了三个小时……最终问题在博主成功运行了一个爬取龙腾网的源代码之后，突然想起来了什么：博主对这两个网页进行查看源代码操作，于是发现……怎么会这样！左边是腾讯新闻的源代码，右边是龙腾网的源代码，可以通过右边的滚动条长度看到连个网页背后哪一个是满满的内容啊！我真的一把辛酸泪，三个小时搞得我眼睛和心疼。 原因及解决通过上面的对比，可以对爬虫有一个新的了解，博主目前没有具体去学习相关原因，但是之前记得有提到过jsoup解析的是静态页面，因此对于左边这种需要动态去不断获取的，只能获得源代码这样很短的HTML文档，当然也有可能是腾讯网不想让你这么容易获得他们的新闻（弟弟行为）。解决方案当然在知道问题后就比较好处理了，博主果断放弃了爬取新闻这个想法，既然能爬取龙腾网的内容，那它做翻译的话我们就业跟着改成新闻翻译APP吧（是的你没看错）。 总结鉴于博主目前爬虫小白，因此想写出来一个更厉害的爬虫来爬取腾讯新闻肯定现在是没有的，不过这里经过一个坑可以总结一个经验：利用jsoup爬取网页的时候，最好先看一下背后的源代码是怎样的，要不然那个弯路走的哟……]]></content>
      <categories>
        <category>java</category>
        <category>Jsoup</category>
      </categories>
      <tags>
        <tag>网页爬取</tag>
        <tag>HTML解析</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之用Jsoup分析HTML]]></title>
    <url>%2F2019%2F09%2F30%2FJava%E4%B9%8B%E7%94%A8jsoup%E5%88%86%E6%9E%90HTML%2F</url>
    <content type="text"><![CDATA[用Jsuop分析Java前言由于最近在APP开发课程中的项目需要实时获取汇率，因此就涉及到了通过Java获取网页并进行数据抽取的工作。博主之前没有用Java爬取HTML并且抽取数据的经历（课堂上跟随老师爬HTML并获取文本内容除外），因此为了保证安卓死丢丢上项目的稳定运行，特地在eclipes上单独尝试了一下，下面是本次学习内容的笔记。 目标网站http://www.usd-cny.com/icbc.htm 这是美元人民币汇率网上的汇率，每一页汇率的表格分布为22行（含表头），5列，根据APP设计要求，这里只需要美元、欧元和韩元的汇率。 爬取数据这一部分非常简单，想必大家也都知道。Java里面有URL类，可以提供对网址型参数的网页内容爬取，处理代码如下： url = new URL(&quot;http://www.usd-cny.com/icbc.htm&quot;);//爬取的地址 HttpURLConnection http = (HttpURLConnection) url.openConnection(); InputStream in = http.getInputStream(); String html = inputStream2String(in);//解析函数是自己写的 Document doc = Jsoup.parse(html);//到这一步就只剩下HTML内容了 经过上面的步骤，就可以获取到HTML网页并且存放在doc变量里了，在控制台上输出doc变量，可以看到就是网页的源代码： 表格内容提取因为内容在表格里，所以这里首先要利用HTML标签将表格取出来。表格在HTML里为table，在取出table之后，按照行取数据，行在HTML里为tr。则最终代码如下： Elements trs = doc.select(&quot;table&quot;).select(&quot;tr&quot;); 在获取到表格之后，首先要按照行将每一条数据取出来，之后按照列取出每一个单元。则根据这个思路，需要两层for循环才能实现，代码如下： for (int i = 1; i &lt; trs.size(); i++) { Elements tds = trs.get(i).select(&quot;td&quot;);//第一行为表头，所以从1开始 for(int j=0;j&lt;tds.size();j++) {//取出每一行中的每一列 String x = tds.get(j).text();//取出每个单元内容 System.out.printf(&quot;%-20s\t&quot;,x);//制表输出 } System.out.println();//输出换行 } 这样的话就可以获得表格的内容了，下面是控制台的输出内容： 因为我们这里只需要三个币种的汇率，因此采用最简单的关键字筛选进行数据提取，则原来的循环代码更改为： for (int i = 1; i &lt; trs.size(); i++) { Elements tds = trs.get(i).select(&quot;td&quot;); String name=tds.get(0).text().trim();//获取名称 if(!name.equals(&quot;美元&quot;)&amp;&amp;!name.equals(&quot;欧元&quot;)&amp;&amp;!name.equals(&quot;韩币&quot;)){//如果不是需要的币种 continue;//跳出本次循环 } else { for(int j=0;j&lt;tds.size();j++) { String x = tds.get(j).text().trim();//获取汇率 System.out.printf(&quot;%-20s\t&quot;,x);//制表输出 } } System.out.println();//换行 } 最终就能得到想要币种的汇率了！ 知识点1. HTML标签内容提取：因为网页是由HTML标记的，所以通过HTML关键词就能通过select函数获取到不同的部件，如代码： Elements trs = doc.select(&quot;table&quot;).select(&quot;tr&quot;); 2. HTML表格内容遍历：由于从HTML文件里取出的table存放在Elements对象里，因此可以通过表格的属性来对table进行遍历和输出。这里有两个很关键的函数(trs为经过标签提取出来的table)： trs.get(int i)函数：该函数可以直接获取trs表中的第i条数据 trs.size()函数：该函数可以获得当前表trs有多少行 3. String字符串制表输出：以前博主在控制台表格输出的时候不知道怎么对齐，为了大致能将就着看，就一般采用占位长度这样的方法，但是会有一个问题，就是每一行的第一个数据长度不一样，导致正一行有可能会比较短或者比较长，最终整个表格不同行之间参差不齐。在这一次的练习中，博主终于发现了java里的制表输出，代码如下： System.out.printf(&quot;%-20s\t&quot;,x);//制表输出 上述代码中，首先采用的是printf，这是C语言中的输出语法，在Java中也有，逗号前为输出控制，后面为输出内容。20前面的符号指左对齐，如果不加符号就是右对齐。20指占位长度，超过则以输出内容的长度为准。如果想指标对其的话则需要在最后加上“\t”，意为制表输出。 小结其实这个网页抓取和分析的项目并不难，但是里面会涉及到一些很重要的小细节。对于初次学习和使用jsoup的人来说，牢记和理解还是很重要的，以下是完整的代码（包的引用这里略去）： public class GetHtml { public static void main(String[] args) { URL url; try { url = new URL(&quot;http://www.usd-cny.com/icbc.htm&quot;); HttpURLConnection http = (HttpURLConnection) url.openConnection(); InputStream in = http.getInputStream(); String html = inputStream2String(in); Document doc = Jsoup.parse(html); Elements trs = doc.select(&quot;table&quot;).select(&quot;tr&quot;); // 关键的一步 从html中把课表解析出来 for (int i = 1; i &lt; trs.size(); i++) { Elements tds = trs.get(i).select(&quot;td&quot;); String name=tds.get(0).text().trim();//获取名称 if(!name.equals(&quot;美元&quot;)&amp;&amp;!name.equals(&quot;欧元&quot;)&amp;&amp;!name.equals(&quot;韩币&quot;)){//如果不是需要的币种 continue;//跳出本次循环 } else { for(int j=0;j&lt;tds.size();j++) { String x = tds.get(j).text().trim();//获取汇率 System.out.printf(&quot;%-20s\t&quot;,x);//制表输出 } } System.out.println();//换行 } } catch (IOException e) { e.printStackTrace(); } } private static String inputStream2String(InputStream inputStream) throws IOException { final int bufferSize = 1024; final char[] buffer = new char[bufferSize]; final StringBuilder out = new StringBuilder(); Reader in = new InputStreamReader(inputStream, &quot;gb2312&quot;); while (true) { int rsz = in.read(buffer, 0, buffer.length); if (rsz &lt; 0) break; out.append(buffer, 0, rsz); } return out.toString(); } } 参考链接[https://blog.csdn.net/qq_42146630/article/details/80292742]]]></content>
      <categories>
        <category>Java</category>
        <category>Jsoup</category>
      </categories>
      <tags>
        <tag>网页爬取</tag>
        <tag>HTML解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言趣味编程之回文数]]></title>
    <url>%2F2019%2F07%2F03%2FC%E8%AF%AD%E8%A8%80%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言由于之前写好之后没有保存，这里就不再重写，直接上代码： 回文数#include&lt;stdio.h&gt; #include &lt;math.h&gt; int juje(long res){ int size=0;//记录长度 int i=0;//循环比较 long resT=res;//尾部逆向扫描 long resH=res;//手部正向扫描 int tail=0;//逆向取值 int head=0; //正向取值 long down=0;//正向取值时的除数 resH=res;//初始化赋值 resT=res; while(res&gt;=10){//计算数字有几位，实际上有size+1位 size++; res=res/10; } for(i=size;i&gt;=0;i--){ tail=resT%10;//逆向取余数 resT=resT/10;//逆向保存商 down=pow(10,i); head=resH/down;//正向取商 resH=resH%down;//正向保存余数 // printf(&quot;head=%d &quot;,head); // printf(&quot;tail=%d\n&quot;,tail); if(tail!=head)//如果不相等就跳出 break; } if(i==-1)//说明前后对称 return 1; else return 0; } int main(){ int i=1; for(i=1;i&lt;=256;i++){ if(juje(i*i)){ printf(&quot;%5d&quot;,i); printf(&quot;%8d\n&quot;,i*i); } } return 0; } 回文素数#include&lt;stdio.h&gt; #include&lt;math.h&gt; int pri(int pri); int juje(long res); int main(){ int i=0; int x=0; int y=0; for(i=11;i&lt;1000;i++){ x=pri(i); if(x==1){ y=juje(i); if(y==1) printf(&quot;%10d\n&quot;,i); } } return 0; } int pri(int pri){//判断是否为素数，如果是则返回1 int i=0; for(i=pri-1;i&gt;1;i--){ if(pri%i==0) break; } if(i==1) return 1; else return 0; } int juje(long res){//判断是否为回文数，是则返回1 int size=0;//记录长度 int i=0;//循环比较 long resT=res;//尾部逆向扫描 long resH=res;//手部正向扫描 int tail=0;//逆向取值 int head=0; //正向取值 long down=0;//正向取值时的除数 resH=res;//初始化赋值 resT=res; while(res&gt;=10){//计算数字有几位，实际上有size+1位 size++; res=res/10; } for(i=size;i&gt;=0;i--){ tail=resT%10;//逆向取余数 resT=resT/10;//逆向保存商 down=pow(10,i); head=resH/down;//正向取商 resH=resH%down;//正向保存余数 if(tail!=head)//如果不相等就跳出 break; } if(i==-1)//说明前后对称 return 1; else return 0; } 回文数的产生#include&lt;stdio.h&gt; #include&lt;math.h&gt; long reverse(long num); int juje(long res); int main(){ int base=99; int juj=0; int REbase; while(juj==0){ REbase=reverse(base);//得到逆向数 printf(&quot;%d+%d=&quot;,base,REbase); base=base+REbase;//两数相加 printf(&quot;%d\n&quot;,base) ; juj=juje(base); } } long reverse(long num){ int size=0; int i=0; int bit=0; int down=0; long reverse=0; long temp=0; temp=num; while(temp&gt;0){ temp=temp/10; size++; } i=size; for(i=size-1;i&gt;=0;i--){ bit=num%10; num=num/10; // printf(&quot;%3d&quot;,bit); down=pow(10,i); // printf(&quot;%9d\n&quot;,down); reverse=reverse+bit*down; } return reverse; } int juje(long res){ int size=0;//记录长度 int i=0;//循环比较 long resT=res;//尾部逆向扫描 long resH=res;//手部正向扫描 int tail=0;//逆向取值 int head=0; //正向取值 long down=0;//正向取值时的除数 resH=res;//初始化赋值 resT=res; while(res&gt;=10){//计算数字有几位，实际上有size+1位 size++; res=res/10; } for(i=size;i&gt;=0;i--){ tail=resT%10;//逆向取余数 resT=resT/10;//逆向保存商 down=pow(10,i); head=resH/down;//正向取商 resH=resH%down;//正向保存余数 if(tail!=head)//如果不相等就跳出 break; } if(i==-1)//说明前后对称 return 1; else return 0; }]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
        <category>趣味数字</category>
      </categories>
      <tags>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言数据结构之链表（二）]]></title>
    <url>%2F2019%2F07%2F01%2FC%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言接上一节链表的讲解，下文中操作均在已创建好的链表基础上，参考教程跳转 链表操作链表操作主要也是“插查删改”，相对于顺序表，链表跟擅长插入和删除； 元素插入插入元素有三种：1.首部插入；2.尾部插入；3.中间插入；步骤：1.找到插入的位置；2.让新节点的指针域指向位置的后继元素；3.让位置前的指针域指向新的结点的地址；注意要让新结点先指向后面的链表之后才能让原来的结点指向新结点； *代码： //p为原链表，elem表示新数据元素，add表示新元素要插入的位置 link * insertElem(link * p,int elem,int add){ link * temp=p;//创建临时结点temp for (int i=1; i&lt;add; i++) {//利用循环找到插入位置 if (temp==NULL) {//判断插入位置是否有效 printf(&quot;插入位置无效\n&quot;); return p;//立刻返回原来的链表 } temp=temp-&gt;next;//结点不断后移 } link * c=(link*)malloc(sizeof(link));//创建插入结点c c-&gt;elem=elem;//确定数据域 //向链表中插入结点 c-&gt;next=temp-&gt;next;//让新结点指向后面的链条 temp-&gt;next=c;//让前面的结点指向新的结点 return p; } 注意：在循环找插入位置时，一定要先判断一下是否已经超出链表长度 元素删除 链表删除其实就是让前一个结点的指针域直接指向后一个的后一个，值得注意的是，对于已经删除的结点，一定要记得释放空间，步骤如下： 1.指针向后移动两个结点； 2.对删除的结点进行释放； //p为原链表，add为要删除元素的值 link * delElem(link * p,int add){ link * temp=p;//temp指向被删除结点的上一个结点 for (int i=1; i&lt;add; i++) {//循环找到删除位置 temp=temp-&gt;next; } link * del=temp-&gt;next;//单独设置一个指针指向被删除结点，以防丢失 temp-&gt;next=temp-&gt;next-&gt;next;//删除某个结点的方法就是更改前一个结点的指针域 free(del);//释放内存 return p;//返回删除结点后的链表 } 元素查找元素查找的思路其实就是挨个一个一个对比，如果有要查找的元素，那么就返回位置，否则就返回NULL表示没有找到，步骤：代码： //p为原链表，elem表示被查找元素、 int selectElem(link * p,int elem){ //新建一个指针t，初始化为头指针 p link * t=p; int i=1; //由于头节点的存在，因此while中的判断为t-&gt;next while (t-&gt;next) { t=t-&gt;next;//指针后移 if (t-&gt;elem==elem) { return i; } i++; } //程序执行至此处，表示查找失败 return -1; } 元素更新这一操作的思路也很简单，只要找到位置，并对结点内的数据域进行修改就可以了。代码： //更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值 link *amendElem(link * p,int add,int newElem){ link * temp=p; temp=temp-&gt;next;//在遍历之前，temp指向首元结点 //遍历到被删除结点 for (int i=1; i&lt;add; i++) { temp=temp-&gt;next; } temp-&gt;elem=newElem; return p; } 小结 在上述的所有代码中，我们会发现，最常见的操作就是下面这行代码： temp=temp-&gt;next; 类似这种更改指针的语言，其实我们可以发现，在链表的查插删改操作中，最重要的就是指针操作了，因此需要格外注意这一点。]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言数据结构之链表（一）]]></title>
    <url>%2F2019%2F07%2F01%2FC%2F</url>
    <content type="text"><![CDATA[前言本节开始讲解链表，参考教程：连接 基本结构头指针单纯的一个指针，其特点在于永远指向链表的第一个节点的位置，便于后期找到链表并使用表中的数据； 节点链表的每一个节点由两部分组成：1.数据域：每个节点的元素本身；2.指针域：每个节点存放下一个节点地址的部分，指向后继元素；代码： typedef struct Link{ char elem; //数据域 struct Link * next; //指针域 }link; 这样的话就创建出了节点的结构体； 头结点&emsp;其实就是一个不存任何数据的空节点，通常作为链表的第一个节点,一般里面存储的是链表的长度。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题； 创建链表步骤：1.获得一个头指针；2.不断创建多个节点，并且将他们前后相连形成逻辑前后关系；代码： link * initLink(){ link * p=NULL;//获得头指针 link * temp = (link*)malloc(sizeof(link));//创建首元节点 //首元节点先初始化 temp-&gt;elem = 1; temp-&gt;next = NULL; p = temp;//头指针指向首元节点 //从第二个节点开始创建 for (int i=2; i&lt;5; i++) { //创建一个新节点并初始化 link *a=(link*)malloc(sizeof(link)); a-&gt;elem=i; a-&gt;next=NULL; //将temp节点与新建立的a节点建立逻辑关系 temp-&gt;next=a; //指针temp每次都指向新链表的最后一个节点 temp=temp-&gt;next; //temp=a;//这一句和上一句一个意思 } //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表 return p; } 上述代码创建了一个存储了{1,2,3,4}且没有头结点的链表，有头结点的链表如下： link * initLink(){ link * p=(link*)malloc(sizeof(link));//创建一个头结点 link * temp=p;//声明一个指针指向头结点， //生成链表 for (int i=1; i&lt;5; i++) { link *a=(link*)malloc(sizeof(link)); a-&gt;elem=i; a-&gt;next=NULL; temp-&gt;next=a; temp=temp-&gt;next; } return p; } 链表输出void display(link *p){ link* temp=p;//将temp指针重新指向头结点 //只要temp指针指向的结点的next不是Null，就执行输出语句。 while (temp-&gt;next) { temp=temp-&gt;next; printf(&quot;%d&quot;,temp-&gt;elem); } printf(&quot;\n&quot;); }]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件读写总结（二）]]></title>
    <url>%2F2019%2F06%2F30%2F%E8%A8%80%E8%81%94%E7%B3%BB%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言本节接着上一节继续记录…本文参考教程连接 文件的随机读写在实际的程序设计中，经常需要从文件的某个指定位置处开始对文件进行选择性的读写操作，这时，首先要把文件的读写位置指针移动到指定处，然后再进行读写，这种读写方式称为对文件的随机读写操作。fseek()函数： int fseek(FI：LE *fp, long offset, int origin);//原函数 fseek(fp,10L,SEEK_SET); fseek(fp,10L,SEEK_CUR); fseek(fp,-20L,SEEK_END); 函数功能：把文件读写指针调整到从 origin 基点开始偏移 offset 处，即把文件读写指针移动到 origin+offset 处。函数参数：1) origin：文件读写指针移动的基准点（参考点）。基准位置 origin 有三种常量取值：SEEK_SET、SEEK_CUR 和 SEEK_END，取值依次为 0，1，2。SEEK_SET:文件开头，即第一个有效数据的起始位置。SEEK_CUR：当前位置。SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。2) offset：位置偏移量，为 long 型，当 offset 为正整数时，表示从基准 origin 向后移动 offset 个字节的偏移；若 offset 为负数，表示从基准 origin 向前移动 |offset| 个字节的偏移。返回值：成功，返回 0；失败，返回 -1。例如，若 fp 为文件指针，则 seek (fp,10L,0); 把读写指针移动到从文件开头向后 10 个字节处。 fSeek(fp,10L,1); 把读写指针移动到从当前位置向后 10 个字节处。 fseek(fp,-20L,2); 把读写指针移动到从文件结尾处向前 20 个字节处。ftell()函数： ftell (FILE *fp); 函数功能：用于获取当前文件读写指针相对于文件头的偏移字节数。]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文件读写</tag>
        <tag>随机读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言数据结构之排序算法]]></title>
    <url>%2F2019%2F06%2F29%2FC%E8%AF%AD%E8%A8%80%E8%81%94%E7%B3%BB%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2%2F</url>
    <content type="text"><![CDATA[前言这一期介绍C语言编写的各种排序算法，有些算法有可能并没有实现很好的移植性，主要还是在于复习和理解： 正文冒泡排序关键词：双重循环、前后比较、相邻交换；思路：冒泡的核心思想其实只需要记住：两个for循环，数组前后比较，按照需求进行位置对调就可以。博主每次并不实际记忆什么条件下进行交换，因为只要查看输出结果，就可以知道什么条件下是升序什么情况下是降序。 #include&lt;stdio.h&gt; void bubble(int arr[],int len){ int i=0; int j=0; int temp=0; for(i=0;i&lt;len-1;i++){ for(j=i+1;j&lt;len;j++){ if(arr[i]&lt;arr[j]){ temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } } } int main(){ int arr[] = {22, 34, 3, 32, 82, 55, 89,50, 37, 5, 64, 35, 9, 70}; int len=0; int i=0; len=(int)sizeof(arr)/(int)sizeof(arr[0]); bubble(arr,len); for(i=0;i&lt;len;i++) printf(&quot;%3d&quot;,arr[i]); } 注意：1.数组长度的计算会使用到sizeo()函数，由于sizeof这里计算的是所占的字节数，因此还需要除以每个元素的长度； 选择排序关键词：双重循环、最值挑选，非相邻交换思路：顾名思义，选择排序即不断地在乱序的数组中寻找出最值（最小或最大），然后将它放在数组里。以升序为例，通常思路为：先以乱序数组第一个为最小值，将其与后面每个数字挨个比较，如果发现有更小的，则更新对最小值的记录并记下这个更小值的位置，以此循环直至数组结束。 #include&lt;stdio.h&gt; void select(int arr[],int len){ int i=0,j=0; int temp=0; int min; int flag=0; for(i=0;i&lt;len-1;i++){ min=arr[i]; for(j=i+1;j&lt;len;j++){ if(arr[j]&lt;min){ min=arr[j]; flag=j; } } temp=arr[i]; arr[i]=min; arr[flag]=temp; } } int main(){ int arr[] = {22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70}; int len=(int)sizeof(arr)/(int)sizeof(arr[0]); int i=0; select(arr,len); for(i=0;i&lt;len;i++) printf(&quot;%3d&quot;,arr[i]); return 0; } 注意：1.为了避免频繁的使用数组交换，可以将当前最小值存放在一个变量中，另外需要flag记下位置，在遍历完所有乱序数字后再进行位置交换，这样一个长度为n的数组最多交换n次。 插入排序关键词：双重循环、前后比较、挪位、相邻交换思路：插入排序需要记住的最大特点就在于，它会出现大量的元素向前或者向后挪位，这取决于乱序数组的数据结构，一般来讲如果不是链表，那么这样的重复操作就不能省去了。另外一个需要记忆的地方就是，它的大循环是从左到右的正循环，但是子循环则是以大循环为起始点的逆向扫描，因此大循环不能从0开始，需要从1开始。本代码在编写过程中，选择采用了一次对比一次交换的方法，严格意义上这不是插入操作，但最终效果时相同的。 #include&lt;stdio.h&gt; void insert1(int arr[],int len){ int i=0,j=0; int temp; for(i=1;i&lt;len;i++){ for(j=i;j&gt;=1 &amp;&amp; arr[j-1]&lt;arr[j];j--){//要求后面小于签一个才能开始进行插入操作 temp=arr[j-1];//这里是交换操作，但最终效果等价于插入操作 arr[j-1]=arr[j]; arr[j]=temp; } } } void insert2(int arr[],int len){ int i=1,j=0,k=1,flag=0;//这里需要格外注意初始值赋值 int temp=arr[0]; for(i=1;i&lt;len;i++){ j=i; while(j&gt;0 &amp; arr[j-1]&gt;arr[i]) j=j-1; flag=j;//找到插入点 temp=arr[i];//保存向后移动时的最后一个元素 k=i;//起始挪动位置 while(k&gt;=flag){ arr[k]=arr[k-1];//以此挪动覆盖 k--; } arr[flag]=temp;//最后一个覆盖插入点 } } int main(){ int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); int i=0; insert2(arr,len); for(i=0;i&lt;len;i++){ printf(&quot;%3d&quot;,arr[i]); } return 0; } 注意：1.上面的排序算法中，并没有严格遵守插入操作的定义。按照插入的思想，应该是在多次对比结束后进行数组元素依次移动并插入，而不是insert1()函数中的比较一次插入一次。博主在完成上面的代码之后也尝试了先比较再挪动插入的算法insert2()，亲测代码体验极差：虽然减少了赋值的次数，但是编写起来却不简单。另外，如果想要少操作，那么这里肯定就需要更多的变量了，因此这两种算法在性能上不是一眼就能分出高低的，个人推荐使用insert1()。2.博主亲测，这种算法需要格外注意父循环和子循环的上下界。 快速排序关键词：下标、递归、左小右大思路：快速排序是众多排序算法中及其重要和优秀的算法，尤其适用于对大数据的排序，但是其逻辑和程序编写也相对要复杂一些，因为会涉及到递归或者迭代。快速排序采用了分而治之的思想：1.以一个数为基准，将序列中的其他数往它两边扔，例如将所有小于的都扔到左边，大于的扔到右边，至于扔过去之后左右两边是否是有序则暂且不管。2.对于“扔”这个动作，这里采用的是交换，而不是插入。因为对于数组来说，插入是它不擅长的工作。3.1-2步骤完成之后，接下来就是将分好的两组继续按照上述步骤进行折半“扔”的操作，这里一般采用递归比较好理解。以下是源代码，博主这里参考了一篇教程，附上链接 # include &lt;stdio.h&gt; //递归算法 void Swap(int *p, int *q); //交换函数 void QuickSort(int *a, int low, int high); int main(void) { int i; int a[] = {22, 34, 3, 32, 82, 55, 89,50, 37, 5, 64, 35, 9, 70}; int len=(int)sizeof(a)/(int)sizeof(a[0]); QuickSort(a, 0, len-1); for (i=0; i&lt;len; ++i) printf(&quot;%d &quot;, a[i]); return 0; } void Swap(int *p, int *q) { int temp; temp = *p; *p = *q; *q = temp; } void QuickSort(int *a, int low, int high){//数组、数组起始下标、数组结尾下标 int i = low; int j = high; int key = a[low];//初始化以第一个为关键数字 if (low &gt;= high){ //递归结束条件 return ; } while (low &lt; high){//循环一次，比较一轮 while (low &lt; high &amp;&amp; key &lt;= a[high]){ --high; //下标前移 } if (key &gt; a[high]){//大的扔到右边 Swap(&amp;a[low], &amp;a[high]); ++low; } while (low &lt; high &amp;&amp; key &gt;= a[low]){ ++low; //下标后移 } if (key &lt; a[low]){//小的扔到左边 Swap(&amp;a[low], &amp;a[high]); --high; } } QuickSort(a, i, low-1); //左递归 QuickSort(a, low+1, j); //右递归 } 希尔排序关键词：步长、插入排序、不稳定思路：讲真这里博主并不想介绍它的思路，因为相对于其他算法，该算法确实要更难一些，但是它却是首个突破n^2的排序算法。1.将整个乱序数组切割为若干个子序列（通过规定好的步长，隔几个数字选一个，最终得到若干个子序列）；2.对这几个子序列分别直接进行插入排序；3.缩小步长（又称增量），重复1-2步骤，直到步长足够小，这个是哦户序列中的圆度基本有序；4.对全体元素进行一次直接插入排序；以下实现代码来自于菜鸟教程 #include&lt;stdio.h&gt; void shell_sort(int arr[], int len) { int gap=len, i, j; int temp; for (gap = len&gt;&gt;2; gap &gt; 0; gap = gap&gt;&gt;2) for (i = gap; i &lt; len; i++) { temp = arr[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; } } int main(){ int i=0; int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); shell_sort(arr, len); for(i=0;i&lt;len;i++) printf(&quot;%3d&quot;,arr[i]); printf(&quot;\n&quot;); }]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件读写总结（一）]]></title>
    <url>%2F2019%2F06%2F29%2F%E8%AF%AD%E8%A8%80%E8%81%94%E7%B3%BB%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[前言&emsp;文件读写是C语言基本语法中要求掌握的部分，博主在复习C的时候在这里专门整理一下，以便日后使用时能够快速理解和熟悉。 基本概念文件文件是操作系统管理数据的基本单位，这里需要记住它的三个要素：1.文件路径2.文件名3.文件后缀名后两个要素这里不细说，需要注意的是路径的两种写法： D:\\WorkSpace\\FileFolder\\file.txt D:/WorkSpace/FileFolder/file.txt &emsp;记忆的话就简单记成除法单杠就好啦，博主也没想出来什么好一点记忆的顺口称呼。 流&emsp;由于程序交互的I/O终端多种多样，为了提高程序设计效率，标准的I/O系统把任意输入的源端或任意输出的终端，都抽象转换成了概念上的“标准 I/O 设备”或称“标准逻辑设备”，换句话说，在程序访问时，需要考虑的是逻辑结构而非物理结构。&emsp;把物理设备抽象成逻辑设备这个动作，则是由标准I/O系统自动完成的。故从这个意义上，可以认为任意输入的源端和任意输出的终端均对应个“流”。&emsp;按照方向，流分为输出流和输入流，按照数据形式，又分为文本流和二进制流。 具体操作头文件#include&lt;stdio.h&gt; //只有这一个 文件的打开与关闭&emsp;在操作前需要记住的是C语言对任何文件进行操作前，都必须先打开文件，即打开“流”，在操作结束后，需要关闭流，释放内存。文件打开：fopen()函数 FILE *fp = NULL; //FILE类型指针变量 fp = fopen(&quot;D:/test.txt&quot;, &quot;r&quot;); //打开成功，fp获得指针变量，否则fp为NULL &emsp;博主这里不写函数原型是因为大多数情况函数原型会刚难以理解，反而具体的应用例子能够很快让人上手,只需要记住：一个指针，两个参数，指针是指成功打开后获得的文件指针，两个参数是指文件路径+文件名和打开模式。&emsp;fopen()打开模式中参数有很多选择，博主三年前学C，平常用的不多，这里只记录之前自己用过的： 模式 含义 说明 r 只读 该模式没有创建文本的能力，因此要求文件必须存在 w 只写 若文件存在，则前清空后重新写；若文件不存在，则会创建文件 a 追加读写 没有创建文本的能力，要求文件必须存在。打开成功则从文件末尾开始写入 模式b 二进制 功能为原模式，但要求为二进制：rb、wb、ab 模式+ 读写 原模式基础上追加读或者写：w+、rb+、ab+，其中只有含有w的模式才能应付文件不存在的情况 文件关闭：fclose()函数 fclose (fp); //fp为已打开文件的指针 &emsp;总之文件关闭就是一句话完事儿的事情，参数是已开文件指针 文件打判断： 这几句基本上是固定好的，为了保证程序健壮性，要求在打开文件之后必须加上： if(NULL==fp){ //判断指针是否为空 printf (&quot;Failed to open the file !\n&quot;); exit (0); //安全起见，强制程序退出 } 应用实例： #include &lt;stdio.h&gt; int main() { FILE *fp = NULL; fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;); if(NULL==fp){ //判断指针是否为空 printf (&quot;Failed to open the file !\n&quot;); exit (0); //安全起见，强制程序退出 } fclose(fp); } 文件结束判断 &emsp;博主把这个放在前面是因为后面会用得到，另外文件的结束判断其实非常重要，有两种方法，不同场合有时候只能用一种方法。 &emsp;当以文本方式读写文件时，可以用EOF判断文件是否结尾，因为EOF=-1，而字符的ASCII码不可能为负数。 getc(fp)!=EOF &emsp;当以二进制方式读写文件时，只能用feof函数判断，因为二进制读取数值，可能为负。feof不仅适用于二进制打开，文本方式打开也适用 feof(fp) //当未读到结尾时，返回值为0，读到结尾时，返回值为1 注意：只有读出所有的数据之后，再读一次，函数feof(fp)的返回值才为真，因此如果想计数TXT中有多少个字符，需要在计数结束之后-1。 文件顺序读写 &emsp;文件的顺序读写就是只文件中数据的存放顺序和读出来或者写进去的顺序是一致的。 单个字符的写入与读出 写入一个字符： fputc(&apos;a&apos;,fp); 读出一个字符： fgetc(fp); 其他关键点: rewind (fp); //把 fp 所指向文件中的读写位置重新调整到文件开始处。 while(p!=&apos;\0&apos;) //判断字符串是否结束 while(!feof(fp)) 应用实例： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main (void){ char c,p; char str[200]=&quot;hello world!&quot;; int i=0; FILE *fp=fopen(&quot;test.txt&quot;,&quot;r+&quot;); if(fp==NULL) printf(&quot;no test.txt&quot;); p=str[0]; while(p!=&apos;\0&apos;){ fputc(p,fp); i++; p=str[i]; } rewind (fp); while(!feof(fp)){ c=fgetc(fp); printf(&quot;%c&quot;,c); } fclose(fp); return 0; } 字符串的写入与读出写入一个字符串： fputs(“hello world\n”, fp); 读出一个字符串： fgets(buffer,100,fp); 函数功能：从 fp 所指向的文件内，读取若干字符（一行字符串），并在其后自动添加字符串结束标志 ‘\0’ 后，存入 s 所指的缓冲内存空间中（s 可为字符数组名），直到遇到回车换行符或已读取 size-1 个字符或已读到文件结尾为止。该函数读取的字符串最大长度为 size-1。参数fp: 可以指向磁盘文件或标准输入设备stdin。注意：fgets()函数在遇到’\0’或者读取到size-1时会自动停止，因此如果想以字符串的形式把文件读完，需要运用循环。 字符串屏幕输出： //方法1 fputs (buffer, stdout);//把字符串输出到屏幕 //方法2 fgets(buffer,100,fp); printf(&quot;%s&quot;,buffer); 应用实例： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define MAX_SIZE 30 //字符数组大小 int main (void) { char buffer[30]=&quot; &quot;; char str1[]=&quot;hello wolrd!\n&quot;; char str2[]=&quot;i love C \n&quot;; char str3[]=&quot;i love my life\n&quot;; FILE *fp; int i; fp=fopen (&quot;file.txt&quot;, &quot;w+&quot;) ; //&quot;w+&quot;模式：先写入后读出 if(NULL==fp){ printf (&quot;Failed to open the file !\n&quot;); exit (0); } fputs (&quot;我佛了\n&quot;, fp) ; fputs (str2, fp) ; fputs (str3, fp) ; rewind (fp); while (fgets(buffer,MAX_SIZE,fp) !=NULL) fputs (buffer, stdout) ; rewind (fp); fgets(buffer,100,fp); printf(&quot;%s&quot;,buffer); fclose(fp); return 0; }]]></content>
      <categories>
        <category>编程语言总结</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文件读写</tag>
        <tag>顺序读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站使用之poj]]></title>
    <url>%2F2019%2F06%2F29%2F%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E4%B9%8Bpoj%2F</url>
    <content type="text"><![CDATA[前言博主为了提升自己的算法能力，决定空闲时间刷一刷算法题，关于算法题的题库和练习网站，之前在“一些好玩又有用的网站”这篇博文里面有提到过，可以选择在力扣或者北大的poj上面进行练习，博主本次选择了poj进行尝试。另外，由于poj更多提供的是检测，因此博主是现在dev C++上写好程序之后再复制上去提交的。 环境检测系统: 北大poj开发环境: dev C++ 使用过程dev C++关于dev的安装和使用这里就不再多说了，各位编程的朋友们首先肯定擅长各种软件的安装，语言的话dev是提供中文，不过这里需要说明一下，在调试的过程中注意不要对同一个程序打开试图打开两个调试窗口，这个之前博主常用的CodeBlocks有很大的区别。一旦上一个程序调试的黑框框没有关掉还继续进行编译运行，那么是会出错的。博主初次使用时没有注意，也是反应了很长时间才找到原因。 北大poj北京大学程序在线评测系统，这里不再多做介绍，博主主要使用C语言进行题目答案提交，答题者需要注册一个账号。 test之1000题一般来讲，初次使用该系统都会直接复制第一题进行系统熟悉，具体题目就是一个简单的加法题，不过在提交的时候注意一定要选对语言，针对于C语言，在编译语言里面可以选择GCC或者C： 值得注意的是，poj系统非常严格（或者说对于输入考虑不周），多一个空格都会报错，博主在重复提交的时候命名选对了语言敲对了代码但是就是报错，后来才发现是因为在题号后面多跟了一个空格……提交完成之后就可以看到自己的提交状态了： 实战之1003题在完成了对系统的初步测试和熟悉之后，就可以来进行题目解答和提交啦！]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo Admin发布博文]]></title>
    <url>%2F2019%2F06%2F28%2F%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[前言博主上个月终于成功搭建出来了自己的个人博客，可以说开心到飞起结果在激动的连发三片博文之后的一个月内就再也没了动静…终于前些日子有了时间可以发博文，结果发现了一件灰常重要的事情，那就是，博主忘记怎么发博客了（我可真是厉害死了）于是，博主突然明白了回归第一天的博文是什么了，就是记录一下怎么发博文（手动微笑） 发布工具博主的发布工具为Hexo-Admin，详情可以参考它的官方网站Admin并不是一开始自带的，因此在搭建好之后，需要单独再去卸载安装，不要嫌麻烦，毕竟后面发博客用它还是很方便的，至于安装教程，博主懒得写，大家可以自行搜索，有很多大神有教程的 界面介绍打开admin主页后事这样的：这里介绍一下各个选项： Post：博客文章的列表，包括已经发布的和尚未发布仍是草稿状态的 Pages：对词云图、归档等的管理，有兴趣的朋友可以去博主的about看看 About：这是关于admin插件从说明 Deploy：可以直接部署到github上去 Settings：这里可以设置admin登录密码，当然还有其他的一些配置 博文发布好！到目前为止基本重新熟悉了环境，那么现在设想你打开电脑，决定进行博文，编写，应该如何去做呢？ step 1首先需要在存放博文的文件夹下右键打开Git Bash Here，需要强调的是，这个文件夹不是存放Hexo下载和安装的文件夹，而是那个专门存放blog的文件夹，比如博主安装Hexo的文件夹名为“Hexo”，而存放博客的文件夹就叫“blog”。博主在重返个人博客的第一天，竟然大脑空空的在Hexo安装文件夹下调试了很久… step 2首先需要将本机上的服务器打开，否则你打开admin主页时看到的就是美丽的404输入命令： hexo server -d 这回服务器运行起来了，现在就阔以打开进行博文编写和发布啦 step 3在博文编写结束之后，可以先看一下效果，如果没有问题，就可以上传到服务器上了。这里需要输入命令： hexo g &amp;&amp; hexo d 当然输入这条语句的前提是你之前得在github和这上面输入过自己的账号，这样之后就可以在固定的位置进行发布了。 小结总之，本博文的目的主要还是在于让博主本人不要忘了怎么发博文，里面省去了很多的细节部分，如果各位朋友想对admin-Hexo了解更多，可以去看我在写此篇博客是的参考博文]]></content>
      <categories>
        <category>Hexo操作汇总记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博文发布</tag>
        <tag>Hexo-Admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Hexo里RSS的添加和取消]]></title>
    <url>%2F2019%2F05%2F19%2F%E5%85%B3%E4%BA%8EHexo%E9%87%8CRSS%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%8F%96%E6%B6%88%2F</url>
    <content type="text"><![CDATA[博主在搭建好博客之后心血来潮添加了RSS订阅，后来有发现与主题不符导致界面不美观又找了许多经验贴才去掉…(no zuo no die)，这里整理一下RSS的添加和取消。 RSS添加1.feed插件安装1.首先在blog所在目录下运行Git Bash Here2.输入指令进行插件安装： npm install hexo-generator-feed 2.配置文件打开站点配置文件_config.yml,在Extension下方添加： #Extensions plugins: hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 打开主题配置文件_config.yml，搜索rss，在后面追加： rss: /atom.xml RSS取消1.配置文件删除首先将添加RSS时配置的文件代码都删去 2.卸载feed插件按理来说将配置的代码删去之后页面就不会再显示了，但是博主在删去之后发现RSS仍然顽强的存在，进行了debug调试和服务器重启都没有用最后博主发现在卸载feed插件之后页面上的RSS才消失 注意：如果完成第一步时RSS就已经消失的朋友不建议再进行卸载同样在根目录下启动Git Bash Here： npm uninstall hexo-generator-feed 卸载之后就可以发现页面山已经没有RSS的标志啦！]]></content>
      <categories>
        <category>汇总记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+GitHub+域名搭建的心路历程]]></title>
    <url>%2F2019%2F05%2F18%2Fhexo-GitHub-%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BA%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文不是教程，只是博主搭建完博客后的一点点总结和经验，但是阅读后会帮助大家在搭建过程中少一些障碍，尽量一次性搭建成功 大概花了一天时间，又重新摸索着在网上学习怎么利用hexo配合GitHub搭建个人博客。博主这方面一片空白，也是东边学一点西边学一点，所以本文不提供系统的怎么搭建的过程，只是记录一下中间出现的问题和解决办法。 基础环境安装 这一方面其实博主本人到现在为止都不知道是做什么的，只知道都安装好就能搭成博客，至于怎么安装，还是参考其他技术大牛们的教程吧。但是这里有需要提醒的： 安装的内容有： 1.git 2.node.js 3.hexo 三者的顺序一般hexo在最后，前两个根据具体教程来 注意hexo文件夹和blog文件夹不是一个东西 安装完之后可以先去申请注册一个GitHub账号，然后按照教程创建一个仓库 主题设置 博主一开始根据教程很快搭好了博客，但是发现主题theme是默认的landscape，因此想换一下，但是问题就在于，博主已经按照教程在landscape的基础上对页面进行了很多的修改，之后突然将主题更换，导致网站直接崩塌(…)因此这里提醒大家，想要什么主题早早找好，然后在网上找对口的教程。由于博主技术不精，所以选择了使用最多的NexT主题，因为相关教程多嘛(捂脸) 博文编写 博主在一开始打好博客之后也激动了好一会，然后突然发现了一个问题：以后想写心得博客怎么办？难道创建一篇心得博客都需要代码创建吗？当然这个问题很快就能解决，博主最后采用了hexo-admin，因为它目前使用起来还算比较顺手，管理的时候也比较方便，具体如何安装以及设置密码请移步其他大佬的技术博客。 域名设置 强烈建议在前面安装基础环境的时候就在网上提前买好域名，否则就会像博主这样在万事俱备只欠域名的情况下猴急猴急的等待域名实名认证通过和GitHub的配置。博主的域名是在阿里云购买的，大家可以根据自己的喜好来。 有几点是需要注意的： 1.有的域名购买需要认证，因此不会购买之后立刻就能用； 2.域名的控制台那里解析的ip，就是你github仓库的ip地址，可以在cmd命令行里面ping一下进行查看； 3.GitHub仓库的settings里面也是需要配置域名的，写上你申请到的域名就可以，例如“xxxx.top”，记得前面不要私自加www，反正我的没有加没有出错； 4.blog/source文件夹下是需要创建一个名为CNAME并且没有后缀名的文件，里面写上自己的域名，这里是需要在前面加上“www”的； 5.在域名这些设置都配置好之后，就可以通过域名在公网上对博客进行访问了，不过刚配置完不要慌(真的这些可以在搭建之前配好，免得后面坐在电脑前静静等待…)，一般过几分钟之后就可以看到自己搭建好的博客和信发布的文章啦！ 后期编写博客和发布 前面已经写到，博主使用的的是hexo-admin，一般在自己的本地进行编辑之后，觉得博文没有问题，直接在blog根目录下输入： hexo g &amp;&amp; hexo d 然后在黑色的命令框里就能看到输出的一堆东西，一般第一次进行这样的GitHub更新，是需要和GitHub上进行ssh设置的，在之后就不需要了。在命令框中显示上传成功之后，博客更新的工作也就完成了。]]></content>
      <categories>
        <category>汇总记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不蒜子文章阅读量显示的问题]]></title>
    <url>%2F2019%2F05%2F18%2Fhexo-GitHub-%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BA%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B-1%2F</url>
    <content type="text"><![CDATA[博主前段时间千辛万苦终于搭好了博客，最后在优化的时候想给每篇文章加一个阅读数量。一般的统计方法有LeanCloud和不蒜子，博主这里选用的不蒜子，因为它修改起来比较快，不需要其他的操作。 于是博主按照网上教程，将文章阅读量这一行改为true：路径为: /themes/next/_config.yml 将文章阅览数修改为true，一般默认的图标为文件，博主在这里改为了眼睛： busuanzi_count: enable: true #这里需要改为true site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer:# 本站总访问量次数 site_pv: false site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: page_pv: true #这里博主改为了true page_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;#图标更换为eye page_pv_footer: 修改完之后发现它竟然竟然显示不在一行，如图：于是博主：喵喵喵？在网上查了一下，原来是不蒜子的统计域名过期了。有兴趣的朋友可以看一下官网的通知：不蒜子统计官网想直接解决的朋友可以不用看官网，简单点就是更新域名的问题： 修改办法：打开不蒜子的统计文件，路径为： /theme/next/layout/_third-party/analytics/busuanzi-counter.swig 你会在里面发现有一个链接地址，不用管它，直接把它用下面的连接更换掉就好了： &quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot; 在修改后进行调试： 问题解决！这是参考的博客连接： hexo博客解决不蒜子统计无法显示问题]]></content>
      <categories>
        <category>汇总记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好玩又有用的网站]]></title>
    <url>%2F2019%2F05%2F18%2F%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E6%B1%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[这里集合很多好玩又冷门的网站，各具特色，包括图片转换到计算机学习，博主持续更新中… 图表icon类easyicon 网站提供大量的图标，还提供在线的图片-图标转换。 快速访问 阿里巴巴矢量图标库 这是由阿里巴巴提供的图标库，在这里可以搜索到大量的图标，不过有些有可能并不免费。 快速访问 计算机学习类VisuAlgo 网站提供很多数据结构与算法的实现动画，可以很形象的先输出内部的实现过程，可以帮助加深理解。 快速访问 力扣题库力扣其实不仅仅是算法与编程的题库，但是目前博主更多使用的是它的题库功能，里面有算法、数据库、shell，题目又会按照难度进行级别划分，而且还可以在网页上进行代码编写，对于想刷算法题的朋友们来说非常实用了。快速访问 poj.org这也是一个算法题库，里面提供代码提交和检查，有过ACM经历的朋友都知道。该网站是北大的，题目众多，可以注册一个账号在上面进行算法练习，另外有可能它们的检查和通过会比较严格快速访问 电影电视剧资源类疯狂影视搜是一个影视资源搜索网站，搜索返回的结果众多，而且界面干净美观（当然有可能是因为我用了广告弹窗拦截），这里不多做介绍，朋友们自己去看就知道了快速访问 插件类AdBlock这是一个浏览器广告拦截插件。博主使用的是360极速浏览器，不知道其他浏览器上有没有AdBlock，但是感觉很多浏览器都能找到的。博主本人真的强推这个插件，过滤效果真的太好，而且还可以选择性对默认不过滤无害但是看上去就不顺眼的地方进行拦截，实在是网页浏览的好伙伴。 文献搜索类SCI-HUB我真的要锤吹爆这个网站好嘛！之前搜索七八篇外文文献，都是要么要钱要么不能下载，害的博主在好几个文献网站注册了好几个账号都没什么用，结果最后在小伙伴的指点下发现了这么一个神奇的网站。真的所有的收费外文文献全！都！有！而且还能下载！可以想象当时博主知道之后那个激动的心情啊。这个网站一般有两个链接可以进入，因为随时都可能会被作废，因此这里只提供链接入口当然了，它主要是用来找外文文献的，中文的上CNKI基本上就满足大部分要求了。]]></content>
      <categories>
        <category>持续更新</category>
      </categories>
      <tags>
        <tag>网站汇总</tag>
        <tag>快速访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速启动创建一篇新的博客1$ hexo new "My New Post" More info: Writing 启动服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
